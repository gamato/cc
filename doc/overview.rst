#######################
CC -- Command & Control
#######################
===========
CC overview
===========

About
=====

CC's (Command & Control) purpose is to provide flexible, scalable, efficient
and easily managed infrastructure / framework.  Among its various goals are:
gathering monitoring data from servers, realtime task submission and feedback,
log file / info file transport, etc.

How it works
============

There is usually one CC instance (server) running per machine.  This can be seen
as one process with usually multiple threads.  It listens on a single socket for
incoming CC messages.  The messages can be of many types and what to do with
them is configured in ``[routes]`` section in CC's config file.  Upon arrival
of a message CC simply dispatches it to one or more handlers.  If no handler is
configured for a message, it is dropped (and logged).  Messages can be dropped
on purpose too (via Disposer handler).  CC handlers try to be fast and if their
task is inherently slow then they (should) do it asynchronously.  Thus CC ought
to be able to handle large amounts of incoming messages.

Another component of CC server may be external daemon processes.  Those usually
perform a dedicated service and communicate with the rest of the world via local
CC instance.  CC can provide them with configuration and keep watching them
(and restarting if required).

Yet another component of CC are tasks.  Tasks are programs, somewhat similar to
daemons, which are executed once per request.  They are managed by TaskRunner
daemon.

All CC components generate log messages of various levels as well as output many
useful statistic counters.  Both can be used to gather better overview of how CC
is performing and/or for debugging purposes.  Levels of details are
configurable, of course.

Handlers
========

There are many handlers already implemented in CC and they are described in
details in `<components/handlers.rst>`_.  Most common ones are Echo, LocalLogger
and Proxy.  `Echo` is used for replying to ping messages from other CC
instances, thus helping to notice network / load issues.  `LocalLogger` writes
log messages generated by CC to log files on file system.  `Proxy` handler
implements a link to another CC server, local or remote.  So whenever we want
something to be sent to another CC instance, we use Proxy handler.  Another
useful, and very often used, handler is `JobMgr`.  It manages external daemon
processes, usually CC jobs (daemons).

Note that it is usually not a good idea to change some more technical (lower
level) options without deeper understanding of implications.

Daemons
=======

These can be any type of standalone programs that can communicate with CC.  But
CC has special support for writing them in Python.  Then it may provide them
with configuration and it will manage them.  There are a few useful daemons
already provided with CC out of box and others can be written and installed
externally.  CC also supports plugins for CC daemons.  Examples of daemons are
InfoScript, PgLogForward, TaskRunner.  They are explained in more details in
`<components/daemons.rst>`_.

Tasks
=====

Task handler is implementation of a specific type of task.  They are executed
by TaskRunner upon request.  Parameters and feedback are task specific.  Request
and response come over CC network, of course.  At the moment there are no useful
task handlers in default CC installation.  Examples are shown in
`<components/tasks.rst>`_.

Use cases
=========

Some common / useful use cases are described in `<use_cases.rst>`_.
